>   根据两个月的系统学习，总结如下：

    1>html,css的基本使用
    2>react创建及组件化编程
    3>引入redux，redux与react结合使用
    4>学习antd组件库
    5>redux中间件
    6>引入react-router实现页面跳转
    7>数据扁平化操作及组装
    8>编写可复用的普适性组件
    9>数据结构的基本介绍

>   ### 一.html,css

    .相对定位:relative,按照元素原始位置对该位置进行定位移动。
    
    .绝对定位:absolute,绝对定位的位置会相对于已定位的最近的父级元素，如果没有已定位的父级元素，它的位置会相对于最初的包含块，以<html>偏移参照为基准。
    
    .固定定位:fixed,固定到页面任何位置。

>   ### 二.react创建-->react核心思想:声明式渲染、基于组件
    1.声明式编程:what,关注做什么  命令式编程:how,关注如何做
    
    eg:for循环遍历函数和map函数，
          --for循环遍历数组，取出元素进行操作，map函数将遍历数组的过程抽出，只关注描述想要什么。
          
    2.渲染:模板 => HTML => 页面视图
    
    react声明式渲染可实现局部渲染，并且只渲染改变的数据。我们只需要维护可变的数据state，react框架帮我们处理DOM操作。
    通过setState(声明式方法)告诉react数据的改变，react自动更新数据改变部分的视图。
        
    3.组件化编程:
      .1>react组件使用render方法，接收数据作为输入，输出页面对应展示的内容，也可拥有其内部的状态数据。
      状态数据改变时组件调用render方法重新渲染。
      .2>好处：低耦合，高复用，复杂性降低，分而治之。
>   ### 三.redux与react结合使用

    redux/API:
      1.store:保存整个应用数据的容器。
      2.action:store数据的唯一来源,通过dispatch()将action传到store。
      (action使用字符串类型的type来表示将要执行的动作,action为一个对象，描述当前发生的事情)。
      3.dispatch:view发送action的唯一方法，接收一个action对象作为参数。
      4.reducer:render是一个函数，接收action和当前state作为参数，返回一个新的state。(算作state的计算过程)。
      5.在生成store的时候将reducer传入createStore方法，生成新的store。
>   ### 四.redux中间件

    实现异步action
      1.将action-->reducer的过程改变，多出一个中间枢纽，变为action-->middleware-->reducer。
      2.中间件主要处理action或者对dispatch进行修饰。
      3.特点：可插拔，可无限延伸，前后可依赖。
> ### 五.数据扁平化

    针对redux单一数据源，在数据展示时会存在不同数据在同一个页面展示、不同页面展示同一个数据的情况，此时采用共享型数据模型。
    将数据统一规划，系统所有页面均基于同一个redux数据模型，数据实体之间关联采用指定的属性，而不是具体的数据实体信息。
      》我们学习的采用第三方库normalizr ，引入schema，定义数据库对象集合。
      》根据action传过来的参数，进行网络请求，请求成功的数据通过normalize()进行转换。
      》转换后的数据存入store虚拟数据库，并且将指定属性的形参数组传给reducer存入。
> ### 六.普适性组件编写

    1.不需要考虑样式问题
    2.不需要关注render dom层级
    3.不需要关注外部注入组件
    4.传入需要显示的数据
    传入必要的EventHeader(比如switch开关，需要传入改变的状态值，通过回调函数触发相应的事件)

> ### 大作业整体实现

1.game2048:

    .1>分析2048游戏规则：
        初始化生成两个随机数(2或4)
        相邻数字相同相加,生成一个随机数
        一个方向挪动后数字中间没有空白块
        没有可加可挪动数字的方向不产生随机数
        死亡判断、胜利判断
    .2>代码实现：
        -->生成随机数：初始化页面时随机生成没有存在数据的二维数组坐标及随机数。
        初始化时函数调用两次，生成两个随机数坐标及数字。
        -->四个方向挪动数字：
        1>相加：使用两个指针，初始指针1指向当前循环数字，指针2指当前数字的下一个，比较是否相同。
        (判断条件：循环从指针1当前数字不为0开始，且下一数字即指针2如果为0，+1操作直到不为0开始判断相加。
        如果不相等，当前数字指针1+1，指针2变为指针1的下一位；如果相等，指针1数字*2，指针2数字变为0，指针1跳到指针2所在的下一位循环)。
        2>去空白块：循环相加后的一行或一列数组，使用两个指针对当前循环指针1为0且最近下一块不为0的数字换位置。
        -->不产生随机数：在相加和挪动操作时使用初始状态为false的的变量，如果有相加或换位置操作则变量置为true，最后判断为true则不调用随机数函数。
        -->死亡判断：循环矩阵，只要有相等或空白块的相邻数据则不结束游戏，判断相等时先判断当前数字的右方。
        符合条件则不死亡，不符合则判断当前数字的下方，直到最后循环结束不符合则游戏结束。
        -->胜利判断：相加操作时只要出现数字为2048则游戏胜利。
2.曲库:

    .1>分析功能点
    .2>规划合理的页面结构
    .3>记录可拆分复用的普适性功能块
    .4>代码实现:
        -->可复用普适性组件：tab标签页，音乐audio组件，删除弹框
        -->单选多选对应不同状态值，显示不同的图标及是否可选择多个音乐
        -->选择音乐后将index值存入数组或从数组删除，以及判断音乐的属性，同时记录在专门的数组或删除(包括plp标记和推荐音乐数组)
        -->底部按钮点击后存储按钮选项，针对不同选择状态值以及数组中是否相应存储数据来改变按钮颜色图标及显示不同的提示内容。
        -->重命名弹框和删除弹框分别针对音乐的name属性和数组存储数据的id发action在reducer里进行相应操作。
        -->音乐audio组件使用自带api及获取数据的属性对标记和进度条拖拽功能进行操作。